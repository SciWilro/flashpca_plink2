// This file was generated by Rcpp::compileAttributes
// Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#include <RcppEigen.h>
#include <Rcpp.h>

#include <Eigen/Core>
#include <Eigen/Dense>
#include <Eigen/Eigen>

using namespace Rcpp;
using namespace Eigen;

#include "randompca.hpp"

// [[Rcpp::export]]
List flashpca_internal(
   Eigen::Map<Eigen::MatrixXd> X,
   int stand,
   unsigned int ndim,
   unsigned int divisor,
   unsigned int maxiter,
   double tol,
   long seed,
   bool verbose,
   bool do_loadings,
   bool return_scale)
{
   try{
      Eigen::MatrixXd Xm = X;

      RandomPCA rpca;
      rpca.stand_method_x = stand;
      rpca.divisor = divisor;
      rpca.verbose = verbose;

      rpca.pca_fast(Xm, 0, ndim, maxiter,
         tol, seed, do_loadings);
      
      NumericMatrix U(wrap(rpca.U));
      NumericMatrix P(wrap(rpca.Px));
      NumericVector d(wrap(rpca.d));

      NumericVector X_mean(0);
      NumericVector X_sd(0);

      // STANDARDIZE_NONE: 0
      if(return_scale && stand != 0)
      {
         NumericMatrix X_meansd(wrap(rpca.X_meansd));
         X_mean = X_meansd(_, 0);
         X_sd = X_meansd(_, 1);
      }
      
      Rcpp::List res;

      if(do_loadings)
      {
         NumericMatrix V(wrap(rpca.V));
         res = Rcpp::List::create(
            Rcpp::Named("values")=d,
            Rcpp::Named("vectors")=U,
            Rcpp::Named("projection")=P,
            Rcpp::Named("loadings")=V,
            Rcpp::Named("center")=X_mean,
            Rcpp::Named("scale")=X_sd
         );
      }
      else
      {
         res = Rcpp::List::create(
            Rcpp::Named("values")=d,
            Rcpp::Named("vectors")=U,
            Rcpp::Named("projection")=P,
            Rcpp::Named("center")=X_mean,
            Rcpp::Named("scale")=X_sd
         );
      }

      return res;
   }
   catch(std::exception &ex)
   {
      forward_exception_to_r(ex);
   }
   catch(...)
   {
      ::Rf_error("flashpca_internal: unknown c++ exception");
   }
   return NA_REAL;
}

// [[Rcpp::export]]
List flashpca_plink_internal(
   std::string fn,
   int stand,
   unsigned int ndim,
   unsigned int divisor,
   unsigned int maxiter,
   unsigned int block_size,
   double tol,
   long seed,
   bool verbose,
   bool do_loadings,
   bool return_scale)
{
   try{
      RandomPCA rpca;
      rpca.stand_method_x = stand;
      rpca.divisor = divisor;
      rpca.verbose = verbose;

      NumericVector X_mean(0);
      NumericVector X_sd(0);

      std::string fam_file, geno_file, bim_file, pheno_file;
      geno_file = fn + std::string(".bed");
      bim_file = fn + std::string(".bim");
      fam_file = fn + std::string(".fam");

      Data data(seed);
      data.verbose = verbose;
      data.stand_method_x = stand; 
      data.read_pheno(fam_file.c_str(), 6);
      data.read_plink_bim(bim_file.c_str());
      data.geno_filename = geno_file.c_str();
      data.get_size();
      data.prepare();

      rpca.pca_fast(data, block_size, ndim,
         maxiter, tol, seed, do_loadings);
      
      NumericMatrix U(wrap(rpca.U));
      NumericMatrix P(wrap(rpca.Px));
      NumericVector d(wrap(rpca.d));

      Rcpp::List res;

      // STANDARDIZE_NONE: 0
      if(return_scale && stand != 0)
      {
         NumericMatrix X_meansd(wrap(rpca.X_meansd));
         X_mean = X_meansd(_, 0);
         X_sd = X_meansd(_, 1);
      }

      if(do_loadings)
      {
         NumericMatrix V(wrap(rpca.V));
         res = Rcpp::List::create(
            Rcpp::Named("values")=d,
            Rcpp::Named("vectors")=U,
            Rcpp::Named("projection")=P,
            Rcpp::Named("loadings")=V,
            Rcpp::Named("center")=X_mean,
            Rcpp::Named("scale")=X_sd
         );
      }
      else
      {
         res = Rcpp::List::create(
            Rcpp::Named("values")=d,
            Rcpp::Named("vectors")=U,
            Rcpp::Named("projection")=P,
            Rcpp::Named("center")=X_mean,
            Rcpp::Named("scale")=X_sd
         );
      }

      return res;
   }
   catch(std::exception &ex)
   {
      forward_exception_to_r(ex);
   }
   catch(...)
   {
      ::Rf_error("flashpca_plink_internal: unknown c++ exception");
   }
   return NA_REAL;
}

// [[Rcpp::export]]
List scca_internal(
   Eigen::Map<Eigen::MatrixXd> X,
   Eigen::Map<Eigen::MatrixXd> Y,
   double lambda1,
   double lambda2,
   unsigned int ndim,
   int stand_x,
   int stand_y,
   int mem,
   long seed,
   int maxiter,
   double tol,
   bool verbose,
   unsigned int num_threads,
   bool useV,
   Eigen::Map<Eigen::MatrixXd> Vinit)
{
   try{

#ifdef _OPENMP
      omp_set_num_threads(num_threads);
#endif

      Eigen::MatrixXd Xm = X;
      Eigen::MatrixXd Ym = Y;

      RandomPCA rpca;
      rpca.stand_method_x = stand_x;
      rpca.stand_method_y = stand_y;
      rpca.verbose = verbose;

      if(useV)
      {
         Eigen::MatrixXd Vm = Vinit;
         rpca.scca(Xm, Ym, lambda1, lambda2, seed,
            ndim, mem, maxiter, tol, Vm);
      }
      else
      {
         rpca.scca(Xm, Ym, lambda1, lambda2, seed,
            ndim, mem, maxiter, tol);
      }

      NumericMatrix U(wrap(rpca.U));
      NumericMatrix V(wrap(rpca.V));
      NumericMatrix Px(wrap(rpca.Px));
      NumericMatrix Py(wrap(rpca.Py));
      NumericVector d(wrap(rpca.d));

      Rcpp::List res;

      res = Rcpp::List::create(
            Rcpp::Named("U")=U,
            Rcpp::Named("V")=V,
            Rcpp::Named("d")=d,
            Rcpp::Named("Px")=Px,
            Rcpp::Named("Py")=Py
      );

      return res;
   }
   catch(std::exception &ex)
   {
      forward_exception_to_r(ex);
   }
   catch(...)
   {
      ::Rf_error("scca_internal: unknown c++ exception");
   }
   return NA_REAL;
}

// [[Rcpp::export]]
List ucca_plink_internal(
   std::string fn,
   Eigen::Map<Eigen::MatrixXd> Y,
   int stand_x,
   int stand_y,
   bool verbose,
   bool return_scale)
{
   try{
      RandomPCA rpca;
      rpca.stand_method_x = stand_x;
      rpca.stand_method_y = stand_y;
      rpca.verbose = verbose;

      NumericVector X_mean(0);
      NumericVector X_sd(0);

      std::string fam_file, geno_file, bim_file, pheno_file;
      geno_file = fn + std::string(".bed");
      bim_file = fn + std::string(".bim");
      fam_file = fn + std::string(".fam");

      Data data(1);
      data.verbose = verbose;
      data.stand_method_x = stand_x; 
      //data.read_pheno(fam_file.c_str(), 6);
      data.Y = Y;
      data.N = Y.rows();
      data.read_plink_bim(bim_file.c_str());
      data.geno_filename = geno_file.c_str();
      data.get_size();
      data.prepare();

      rpca.ucca(data);
      
      NumericMatrix U(wrap(rpca.U));
      NumericMatrix P(wrap(rpca.Px));
      NumericVector d(wrap(rpca.d));

      // STANDARDIZE_NONE: 0
      //if(return_scale && stand != 0)
      //{
      //   NumericMatrix X_meansd(wrap(rpca.X_meansd));
      //   X_mean = X_meansd(_, 0);
      //   X_sd = X_meansd(_, 1);
      //}
      
      Rcpp::List res;

      //if(do_loadings)
      //{
      //   NumericMatrix V(wrap(rpca.V));
      //   res = Rcpp::List::create(
      //      Rcpp::Named("values")=d,
      //      Rcpp::Named("vectors")=U,
      //      Rcpp::Named("projection")=P,
      //      Rcpp::Named("loadings")=V,
      //      Rcpp::Named("center")=X_mean,
      //      Rcpp::Named("scale")=X_sd
      //   );
      //}
      //else
      //{
      //   res = Rcpp::List::create(
      //      Rcpp::Named("values")=d,
      //      Rcpp::Named("vectors")=U,
      //      Rcpp::Named("projection")=P,
      //      Rcpp::Named("center")=X_mean,
      //      Rcpp::Named("scale")=X_sd
      //   );
      //}
      //return res;
      
      NumericMatrix resM(wrap(rpca.res));
      colnames(resM) = StringVector::create("R", "Fstat", "P");
      StringVector rownamesV(data.snp_ids.size());
      for(int i = 0 ; i < data.snp_ids.size() ; i++)
         rownamesV(i) = data.snp_ids[i];
      rownames(resM) = rownamesV;

      res = Rcpp::List::create(
         Rcpp::Named("result")=resM
      );

      return res;
   }
   catch(std::exception &ex)
   {
      forward_exception_to_r(ex);
   }
   catch(...)
   {
      ::Rf_error("ucca_plink_internal: unknown c++ exception");
   }
   return NA_REAL;
}

// [[Rcpp::export]]
List scca_plink_internal(
   std::string fn,
   Eigen::Map<Eigen::MatrixXd> Y,
   double lambda1,
   double lambda2,
   unsigned int ndim,
   int stand_x,
   int stand_y,
   int mem,
   long seed,
   int maxiter,
   double tol,
   bool verbose,
   unsigned int num_threads,
   unsigned int block_size,
   bool useV,
   Eigen::Map<Eigen::MatrixXd> Vinit)
{
   try{

#ifdef _OPENMP
      omp_set_num_threads(num_threads);
#endif

      //Eigen::MatrixXd Ym = Y;

      RandomPCA rpca;
      rpca.stand_method_x = stand_x;
      rpca.stand_method_y = stand_y;
      rpca.verbose = verbose;

      std::string fam_file, geno_file, bim_file, pheno_file;
      geno_file = fn + std::string(".bed");
      bim_file = fn + std::string(".bim");
      fam_file = fn + std::string(".fam");

      Data data(seed);
      data.verbose = verbose;
      data.stand_method_x = stand_x; 
      data.Y = Y;
      data.N = Y.rows();
      data.read_plink_bim(bim_file.c_str());
      data.geno_filename = geno_file.c_str();
      data.get_size();
      data.prepare();

      if(useV)
      {
         Eigen::MatrixXd Vm = Vinit;
         rpca.scca(data, lambda1, lambda2, seed,
            ndim, mem, maxiter, tol, block_size, Vm);
      }
      else
      {
         rpca.scca(data, lambda1, lambda2, seed,
            ndim, mem, maxiter, tol, block_size);
      }

      NumericMatrix U(wrap(rpca.U));
      NumericMatrix V(wrap(rpca.V));
      NumericMatrix Px(wrap(rpca.Px));
      NumericMatrix Py(wrap(rpca.Py));
      NumericVector d(wrap(rpca.d));

      Rcpp::List res;

      res = Rcpp::List::create(
            Rcpp::Named("U")=U,
            Rcpp::Named("V")=V,
            Rcpp::Named("d")=d,
            Rcpp::Named("Px")=Px,
            Rcpp::Named("Py")=Py
      );

      return res;
   }
   catch(std::exception &ex)
   {
      forward_exception_to_r(ex);
   }
   catch(...)
   {
      ::Rf_error("scca_plink_internal: unknown c++ exception");
   }
   return NA_REAL;
}

// [[Rcpp::export]]
List ucca_internal(
   Eigen::Map<Eigen::MatrixXd> X,
   Eigen::Map<Eigen::MatrixXd> Y,
   int stand_x,
   int stand_y,
   bool verbose,
   bool return_scale)
{
   try{
      Eigen::MatrixXd Xm = X;
      Eigen::MatrixXd Ym = Y;

      RandomPCA rpca;
      rpca.stand_method_x = stand_x;
      rpca.stand_method_y = stand_y;
      rpca.verbose = verbose;

      NumericVector X_mean(0);
      NumericVector X_sd(0);

      //std::string fam_file, geno_file, bim_file, pheno_file;
      //geno_file = fn + std::string(".bed");
      //bim_file = fn + std::string(".bim");
      //fam_file = fn + std::string(".fam");

      //Data data(1);
      //data.verbose = verbose;
      //data.stand_method_x = stand_x; 
      ////data.read_pheno(fam_file.c_str(), 6);
      //data.Y = Y;
      //data.N = Y.rows();
      //data.read_plink_bim(bim_file.c_str());
      //data.geno_filename = geno_file.c_str();
      //data.get_size();
      //data.prepare();

      rpca.ucca(Xm, Ym);
      
      NumericMatrix U(wrap(rpca.U));
      NumericMatrix P(wrap(rpca.Px));
      NumericVector d(wrap(rpca.d));

      // STANDARDIZE_NONE: 0
      //if(return_scale && stand != 0)
      //{
      //   NumericMatrix X_meansd(wrap(rpca.X_meansd));
      //   X_mean = X_meansd(_, 0);
      //   X_sd = X_meansd(_, 1);
      //}
      
      Rcpp::List res;

      //if(do_loadings)
      //{
      //   NumericMatrix V(wrap(rpca.V));
      //   res = Rcpp::List::create(
      //      Rcpp::Named("values")=d,
      //      Rcpp::Named("vectors")=U,
      //      Rcpp::Named("projection")=P,
      //      Rcpp::Named("loadings")=V,
      //      Rcpp::Named("center")=X_mean,
      //      Rcpp::Named("scale")=X_sd
      //   );
      //}
      //else
      //{
      //   res = Rcpp::List::create(
      //      Rcpp::Named("values")=d,
      //      Rcpp::Named("vectors")=U,
      //      Rcpp::Named("projection")=P,
      //      Rcpp::Named("center")=X_mean,
      //      Rcpp::Named("scale")=X_sd
      //   );
      //}
      //return res;
      
      NumericMatrix resM(wrap(rpca.res));
      colnames(resM) = StringVector::create("R", "Fstat", "P");
      //StringVector rownamesV(data.snp_ids.size());
      //for(int i = 0 ; i < data.snp_ids.size() ; i++)
      //   rownamesV(i) = data.snp_ids[i];
      //rownames(resM) = rownamesV;

      res = Rcpp::List::create(
         Rcpp::Named("result")=resM
      );

      return res;
   }
   catch(std::exception &ex)
   {
      forward_exception_to_r(ex);
   }
   catch(...)
   {
      ::Rf_error("ucca_internal: unknown c++ exception");
   }
   return NA_REAL;
}

