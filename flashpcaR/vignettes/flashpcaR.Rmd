---
title: "flashpcaR"
author: "Gad Abraham"
date: "`r Sys.Date()`"
output:
   rmarkdown::html_document:
      highlight: tango
      keep_md: true
      toc: true
vignette: >
   %\VignetteIndexEntry{flashpcaR}
   %\VignetteEngine{knitr::rmarkdown}
   %\VignetteEncoding{UTF-8}
---

```{r, echo=FALSE, cache=FALSE}
options(width=80)
```

## Introduction

## Installation

## Examples

We will use chromosome 1 SNPs from the HapMap3 project as a running example.


```{r}
library(flashpcaR)
data(hm3.chr1)
```

Almost all analyses in `flashpcaR` can be run on either a numeric matrix or on a PLINK dataset (bed,bim,fam).

```{r}
# Standardise the genotypes, impute to mean (=0)
X <- scale2(hm3.chr1$bed)
```

```{r}
# Find the path to the PLINK data
fn <- gsub("\\.bed", "",
   system.file("extdata", "data_chr1.bed", package="flashpcaR"))
```

### Principal component analysis (PCA)

Principal component analysis (PCA) is based on the singular-value decomposition
of the the matrix $X$
$$X = U D V^T,$$
where $U$ are the left eigenvectors, $D$ is the diagonal matrix of singular values, and $V$ are the right eigenvectors (also called loadings). PCA can also be done using the eigen-decomposition of $X X^T$
$$X X^T = U S U^T,$$ where $S=D^2$ is the diagonal matrix of eigenvalues.

$X$ is usually centred (mean-subtracted) or standardised (mean subtracted, then divided by standard deviation) before PCA.

For PCA of SNP genotypes (at least in diploid organisms), the common standardisation is
$$X_{ij}^{\prime} = \frac{X_{ij} - 2p_j}{\sqrt{2 p_j (1 - p_j)}},$$
where $X_{ij}$ is the genotype (minor allele dosage $\{0, 1, 2\}$) for the $i$th individual and the $j$th SNP, and $p_j$ is the minor allele frequency (MAF) for the $j$th SNP. In addition, the eigenvalues are divided by the number of SNPs $m$ (equivalent to performing the eigen-decomposition of $XX^T/m$).

#### Using a numeric matrix
```{r}
# X has already been standardised using scale2
f1 <- flashpca(X, stand="none")
```

#### Using a PLINK dataset
```{r}
f2 <- flashpca(fn)
```

#### Plot first two PCs
```{r}
par(mfrow=c(1, 2), pty="s")
plot(f1$vectors[,1:2], xlab="PC1", ylab="PC2",
   col=factor(hm3.chr1$population$population),
   main="Numeric matrix")
plot(f2$vectors[,1:2], xlab="PC1", ylab="PC2",
   col=factor(hm3.chr1$population$population),
   main="PLINK data")
```

#### References

1. Patterson et al 2006, `Population structure and eigenanalysis', _PLOS Genet_ 2(12):e190.
2. Price et al 2006, `Principal components analysis corrects for stratification in genome-wide association studies', _Nat Genet_ 38(8):904-909.
3. Novembre et al 2008, `Genes mirror geography within Europe', _Nature_ 456(7218):98-101.
4. Price et al 2010, `New approaches to population stratification in genome-wide association studies',
_Nat Rev Genet_ 11(7):459-463.
5. Abraham & Inouye 2014, `Fast Principal Component Analysis of Large-Scale Genome-Wide Data',
_PLOS ONE_  9(4): e93766.
6. Galinsky et al 2016, `Fast Principal-Component Analysis Reveals Convergent Evolution of ADH1B in Europe and East Asia', _Am J Hum Genet_ 98(3):456-472.

### Sparse canonical correlation analysis (SCCA)

Sparse canonical correlation analysis (SCCA; Witten et al 2009, Parkhomenko et al 2009) is an extension of
Hotelling's canonical correlation analysis (CCA).

$$\arg \max_{u, v} u^T \Sigma_{XY} v$$
$$\mbox{ s.t. } ||u||_2^2=1, ||v||_2^2=1, ||u||_1\le s_u, ||v||_1\le s_v,$$
where $\Sigma_{XY}$ is the covariance matrix of $X$ and $Y$, $u$ and $v$ are the left and right canonical vectors respectively, and $s_u$ and $s_v$ are constraints on the $L_1$ norms of these vectors, respectively.

#### Example with simulated data

We will simulate $k=20$ phenotypes and perform SCCA using the chr1 genotypes.

```{r}
# Simulate phenotypes
k <- 20
n <- nrow(X)
m <- ncol(X)
B <- matrix(rnorm(m * k), m, k)
Y <- X %*% B + rnorm(n * k)
```

We run SCCA over a 7x3 grid of penalties, infer 3 canonical dimensions
```{r}
# X has already been standardised; Y needs to be standardised
f3 <- scca(X, Y, ndim=3, lambda1=seq(1e-3, 1e-2, length=7),
   lambda2=seq(1e-3, 1e-2, length=3), standx="none", standy="sd")
```

We can also do cross-validation over the grid of penalties
```{r}
# 3-fold cross-validation over a grid of penalties
cv3 <- cv.scca(X, Y, ndim=3, nfolds=3, lambda1=seq(1e-3, 5e-2, length=7),
   lambda2=seq(1e-3, 1e-2, length=3), standx="none", standy="sd")
```

We can plot the cross-validated Pearson correlations (higher is better)
for each pair of penalties on the grid; the x-axis shows the number
of variables with non-zero weight selected in X (higher penalty leads
to fewer SNPs with non-zero weight) and different lines are plotted
for the Y penalties.
```{r}
# Plot cross-validation results for dimension 1
plot(cv3, dim=1)
```
Based on these results, we would select a model with ~1000 SNPs; the choice of 
penalty for Y does not seem to matter much here.

#### References

1. Witten et al 2009, `A penalized matrix decomposition, with applications to 
sparse principal components and canonical correlation analysis', _Biostatistics_ 10:515-534.
2. Witten et al 2009, `Extensions of Sparse Canonical Correlation Analysis with 
Applications to Genomic Data'. _Stat Appl Genet Mol Biol_ 8(1), Article 29.
2. Parkhomenko 2009, `Sparse canonical correlation analysis with application 
to genomic data integration'. _Stat Appl Genet Mol Biol_ 8(1), Article 1.

### Univariate canonical correlation analysis (UCCA, aka ANOVA)

`flashpcaR` also implements the so-called canonical correlation analysis of
`plink.multivariate --mqfam` (https://genepi.qimr.edu.au/staff/manuelF/multivariate/main.html),
which is a per-SNP analysis of association with multiple phenotypes.
To maintain the same familiar CCA terminology but to distinguish this
model from the standard CCA or the SCCA models,
we name it _univariate_ CCA (UCCA); it is actually equivalent to an
F-test for the linear regression of each SNP on the phenotypes.

#### Example with simulated data

Using the same simulated phenotypes from before, we can test the association
of _each SNP_ with all phenotypes.

```{r}
# X has already been standardised; standardise Y too
f4 <- ucca(X, Y, standx="none", standy="sd")
head(f4$result)

# Manhattan plot of the SNP associations
d <- data.frame(hm3.chr1$bim, f4$result)
if(requireNamespace("qqman", quietly=TRUE)) {
   qqman::manhattan(d, chr="V1", bp="V4", p="P", snp="V2")
} else {
   plot(I(-log10(P)) ~ V4, data=d)
}
```

#### References

1. Ferreira & Purcell 2009, `A multivariate test of association',
_Bioinformatics_ 25(1):132-133.
